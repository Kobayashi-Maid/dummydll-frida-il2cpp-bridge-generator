using System.Text;
using Mono.Cecil;

namespace dummydll_frida_il2cpp_bridge_generator;

public static class AssemblyToFridaIl2CppBridgeClasses
{
    private static readonly HashSet<string> GeneratedNames = new HashSet<string>();


    private static readonly string[] BasicTypeNames =
    {
        "System.Void",
        "System.Boolean",
        "System.Int32",
        "System.Int16",
        "System.Int64",
        "System.UInt32",
        "System.UInt16",
        "System.UInt64",
        "System.Byte",
        "System.SByte",
        "System.Single",
        "System.Double",
        "System.String",
        "System.Object"
    };

    private static readonly string[] BasicTypeMappings =
    {
        "void",
        "boolean",
        "number",
        "number",
        "number",
        "number",
        "number",
        "number",
        "number",
        "number",
        "number",
        "number",
        "string",
        "Il2Cpp.Object"
    };

    public static StringBuilder Generate(AssemblyDefinition assembly, bool annotation, bool jsdoc)
    {
        var sb = new StringBuilder();
        sb.AppendLine(
            """
            // <auto-generated>
            // automatically generated by the dummydll-frida-il2cpp-bridge-generator, do not modify.
            // If you encounter any errors in the TypeScript file, please submit an issue to https://www.github.com/Kobayashi-Maid/dummydll-frida-il2cpp-bridge-generator.
            // </auto-generated>

            """);
        sb.AppendLine("import \"frida-il2cpp-bridge\";\n");

        foreach (var type in assembly.MainModule.Types)
        {
            string formattedClassName = FormatClassName(type.FullName);
            if (annotation) sb.AppendLine("// [Class]");
            if (jsdoc)
            {
                sb.AppendLine("/**");
                sb.AppendLine($" * {type.FullName}");
                sb.AppendLine(" */");
            }

            sb.AppendLine(
                $"const {formattedClassName} = Il2Cpp.domain.assembly(\"{assembly.Name.Name}\").image.class(\"{type.FullName}\");");

            foreach (var method in type.Methods)
            {
                string formattedMethodName = FormatMethodName(method.Name);
                string methodDefinition = method.ReturnType == null
                    ? $"const {formattedClassName}$${formattedMethodName} = {formattedClassName}.method(\"{method.Name}\");"
                    : $"const {formattedClassName}$${formattedMethodName} = {formattedClassName}.method<{MapToTypeScriptType(method.ReturnType)}>(\"{method.Name}\");";

                if (GeneratedNames.Contains(methodDefinition))
                {
                    methodDefinition = method.ReturnType == null
                        ? $"const {formattedClassName}$${formattedMethodName} = {formattedClassName}.method(\"{method.Name}\");"
                        : $"const {formattedClassName}$${formattedMethodName}_{method.ReturnType.GetHashCode()} = {formattedClassName}.method<{MapToTypeScriptType(method.ReturnType)}>(\"{method.Name}\");";
                }

                if (annotation)
                {
                    sb.AppendLine($"// [Method]");
                    sb.AppendLine($"// [{method.Attributes.ToString()}]");

                    if (method.ReturnType != null)
                    {
                        sb.AppendLine($"// [ReturnType: {method.ReturnType.FullName}]");
                    }
                }

                if (jsdoc)
                {
                    sb.AppendLine("/**");
                    sb.AppendLine($" * {type.FullName}.{method.Name}");
                    if (method.Parameters.Count > 0)
                    {
                        foreach (var parameter in method.Parameters)
                        {
                            sb.AppendLine(
                                $" * @param {parameter.ParameterType}.{parameter.Name}");
                        }
                    }

                    if (method.ReturnType != null)
                    {
                        sb.AppendLine($" * @returns {method.ReturnType} ");
                    }

                    sb.AppendLine($" */");
                }


                sb.AppendLine(methodDefinition);

                GeneratedNames.Add(methodDefinition);
            }
        }

        return sb;
    }

    private static string FormatClassName(string fullName)
    {
        string formattedClassName = fullName.Replace('.', '_').Replace("`", "$");

        return formattedClassName switch
        {
            "<Module>" => "__Module",
            "<PrivateImplementationDetails>" => "__PrivateImplementationDetails",
            _ when formattedClassName.Contains("<>") => formattedClassName.Replace("<>", "__CompilerGenerated_"),
            _ => formattedClassName
        };
    }

    private static string FormatMethodName(string methodName)
    {
        return methodName.Replace('.', '_').Replace("`", "$").Replace("<", "_").Replace(">", "_").Replace("|", "$");
    }

    private static string MapToTypeScriptType(TypeReference returnType)
    {
        string typeName = returnType.FullName;
        int index = Array.IndexOf(BasicTypeNames, typeName);
        return index >= 0 ? BasicTypeMappings[index] : "Il2Cpp.Object";
    }
}