using System.Text;
using Mono.Cecil;

namespace dummydll_frida_il2cpp_bridge_generator
{
    public static class AssemblyToFridaIl2CppBridgeClasses
    {
        private static readonly string[] BasicTypeNames =
        {
            "System.Void",
            "System.Boolean",
            "System.Int32",
            "System.Int16",
            "System.Int64",
            "System.UInt32",
            "System.UInt16",
            "System.UInt64",
            "System.Byte",
            "System.SByte",
            "System.Single",
            "System.Double",
            "System.String",
            "System.Object"
        };

        private static readonly string[] BasicTypeMappings =
        {
            "void", 
            "boolean", 
            "number", 
            "number",
            "number", 
            "number", 
            "number", 
            "number",
            "number", 
            "number", 
            "number", 
            "number", 
            "string", 
            "Il2Cpp.Object"
        };

        public static StringBuilder Generate(AssemblyDefinition assembly, bool annotation)
        {
            var sb = new StringBuilder();
            sb.AppendLine(
                """
                // <auto-generated>
                // automatically generated by the dummydll-frida-il2cpp-bridge-generator, do not modify.
                // If you encounter any errors in the TypeScript file, please submit an issue to https://www.github.com/Kobayashi-Maid/dummydll-frida-il2cpp-bridge-generator.
                // </auto-generated>
                
                """);
            sb.AppendLine("import \"frida-il2cpp-bridge\";\n");

            foreach (var type in assembly.MainModule.Types)
            {
                string formattedClassName = FormatClassName(type.FullName);
                if (annotation) sb.AppendLine("// Class");
                sb.AppendLine(
                    $"const {formattedClassName} = Il2Cpp.domain.assembly(\"{assembly.Name.Name}\").image.class(\"{type.FullName}\");");
                
                foreach (var method in type.Methods)
                {
                    string formattedMethodName = FormatMethodName(method.Name);
                    string methodDefinition = method.ReturnType == null
                        ? $"const {formattedClassName}$${formattedMethodName} = {formattedClassName}.method(\"{method.Name}\");"
                        : $"const {formattedClassName}$${formattedMethodName} = {formattedClassName}.method<{MapToTypeScriptType(method.ReturnType)}>(\"{method.Name}\");";

                    if (annotation) sb.AppendLine("// Method");
                    sb.AppendLine(methodDefinition);
                }
            }

            return sb;
        }
        
        private static string FormatClassName(string fullName)
        {
            string formattedClassName = fullName.Replace('.', '_').Replace("`", "$");

            return formattedClassName switch
            {
                "<Module>" => "__Module",
                "<PrivateImplementationDetails>" => "__PrivateImplementationDetails",
                _ when formattedClassName.Contains("<>") => formattedClassName.Replace("<>", "__CompilerGenerated_"),
                _ => formattedClassName
            };
        }

        private static string FormatMethodName(string methodName)
        {
            return methodName.
                Replace('.', '_').
                Replace("`", "$").
                Replace("<", "_").
                Replace(">", "_").
                Replace("|", "$");
        }

        private static string MapToTypeScriptType(TypeReference returnType)
        {
            string typeName = returnType.FullName;
            int index = Array.IndexOf(BasicTypeNames, typeName);
            return index >= 0 ? BasicTypeMappings[index] : "Il2Cpp.Object";
        }
    }
}